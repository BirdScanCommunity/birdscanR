#### plotLongitudinalMTR ------------------------------------------------------
#' @title plotLongitudinalMTR
#'
#' @author Fabian Hertner (SBRS)
#' @description Plots the daily MTR values per day and night as a bar plot (Figure 15). For each bar the spread (first and third Quartile) is shown as error bars as well as the numbers of echoes. Periods with no observation are indicated with grey, negative bars.
#'
#' @param mtr data frame with MTR values created by the function ‘computeMTR’. 
#' The MTR data should be computed with one altitude bin, if MTR data with multiple altitude bins are passed to the function, the only the lowest altitude bin is plotted.  
#' The MTR data should be computed per day and night (setting the parameter ‘computePerDayNight’ of the function ‘computeMTR’ to TRUE, otherwise the plot will fail. 
#' @param maxMTR optional numeric variable, fixes the maximum value of the y-Scale of the plot to the given value. If negative or not set, the y-Scale is auto-scaled.
#' @param timeRange optional list of POSIXct vectors length 2, start and end time of the timeranges that should be plotted. The date/time format is “yyyy-MM-dd hh:mm”. 
#' Target timezone has to be added to the times (Figure 14 as example). If not set, all MTR data is plotted in one plot. 
#' @param plotClass character string with the class of which the MTR data should be plotted. If not set or set to “allClasses”, MTR of all classes will be plotted. 
#' @param propObsTimeCutoff 
#' @param plotSpread logical, choose if the spread (first and third quartile) should be plotted.
#' @param filePath character string, path of the directory where the plot should be saved. The function ‘savePlotToFile’ is used to save the plots as pngs with an autogenerated filename.
#'
#' @return pngs stored in the directory specified in filePath
#' @export
#'
#' @examples
#' # plot longitudinal MTR per day and night
#' plotLongitudinalMTR( mtr = mtr_DayNight_25mto1000m, maxMTR = -1, timeRange = timeRangePlot, plotClass = "allClasses", plotSpread = TRUE, filePath = plotDir ) 
plotLongitudinalMTR = function( mtr, maxMTR, timeRange = NULL, plotClass = "allClasses", propObsTimeCutoff = 0.2, plotSpread = TRUE, filePath = NULL )
{
  if( length( mtr[ , 1 ] ) == 0 )
  {
    warning( "no MTR data to plot." )
    return()
  }
  
  # extract classSelection
  if( plotClass == "allClasses" )
  {
    classSelection <- names( mtr )[ grepl( "mtr.", names( mtr ), fixed = TRUE) & !grepl( "allClasses", names( mtr ), fixed = TRUE) ]  
  } else
  {
    classSelection <- names( mtr )[ grepl( "mtr.", names( mtr ), fixed = TRUE) & grepl( plotClass, names( mtr ), fixed = TRUE) ]
  }
  classSelection <- gsub( "mtr.", "", classSelection )
  
  if( length( classSelection ) == 0 ) 
  {
    warning( paste0( "class '", plotClass, "' not present in mtr data." ) )
    return()
  }
  
  # timeRanges to plot
  if( is.null( timeRange ) )
  {
    nPlots <- 1
  } else
  {
    nPlots = length( timeRange )
  }
  
  # make sure only one altitude bin is used
  altitudeChunkId <- min( unique( mtr$altitudeChunkId ) )
  
  for( i in 1 : nPlots )
  {
    if( is.null( timeRange ) )
    {
      mtrPlot <- mtr[ mtr$altitudeChunkId == altitudeChunkId, ]
    } else
    {
      mtrPlot <- mtr[ mtr$altitudeChunkId == altitudeChunkId & mtr$timeChunkBegin > timeRange[[ i ]][ 1 ] & mtr$timeChunkBegin < timeRange[[ i ]][ 2 ], ]  
    }
    
    if( length( mtrPlot[ , 1 ] ) > 0 )
    {
      # get mtr data needed based on classSelection
      mtrPlot <- mtrPlot[ , !grepl( ".", names( mtrPlot ), fixed = TRUE) | grepl( plotClass, names( mtrPlot ), fixed = TRUE) ]
      names( mtrPlot ) <- gsub( paste0( ".", plotClass ), "", names( mtrPlot ) )
      
      # mark timeBins as not Observed if proportional observationtime smaller than propObsTimeCutoff
      mtrPlot$proportionalTimeObserved[ is.na( mtrPlot$proportionalTimeObserved ) ] <- 0
      mtrPlot$mtr[ mtrPlot$proportionalTimeObserved < propObsTimeCutoff | is.na( mtrPlot$mtr ) ] <- 0
      mtrPlot$nEchoes[ mtrPlot$proportionalTimeObserved < propObsTimeCutoff | is.na( mtrPlot$mtr ) ] <- 0
      mtrPlot$mtrFirstQuartile[ mtrPlot$proportionalTimeObserved < propObsTimeCutoff | is.na( mtrPlot$mtr ) ] <- 0
      mtrPlot$mtrThirdQuartile[ mtrPlot$proportionalTimeObserved < propObsTimeCutoff | is.na( mtrPlot$mtr ) ] <- 0
      mtrPlot <- data.frame( mtrPlot, obs = 0 )
      mtrPlot <- data.frame( mtrPlot, obsType = "dayObserved" )
      levels( mtrPlot$obsType ) <- c( "dayObserved", "nightObserved" )
      mtrPlot$obsType[ mtrPlot$dayOrNight == "night" ] <- "nightObserved"
      if( maxMTR >= 0 )
      {
        mtrPlot$obs[ mtrPlot$proportionalTimeObserved < propObsTimeCutoff | is.na( mtrPlot$mtr ) ] <- maxMTR * -0.015
        yScale <- c( maxMTR * -0.07, maxMTR )
      } else
      {
        mtrPlot$obs[ mtrPlot$proportionalTimeObserved < propObsTimeCutoff | is.na( mtrPlot$mtr ) ] <- max( mtrPlot$mtrThirdQuartile ) * -0.015
        maxScale <- max( c( max( mtrPlot$mtrThirdQuartile ), max( mtrPlot$mtr ) ), na.rm =  TRUE )
        yScale <- c( maxScale * -0.07, maxScale )
      }
      
      # plot
      subtitle <- paste0( format( mtrPlot$timeChunkDate[ 1 ], "%d-%b-%Y" ), 
                          " to ", 
                          format( mtrPlot$timeChunkDate[ length( mtrPlot$timeChunkDate ) ], "%d-%b-%Y" ),
                          "\n",
                          min( mtrPlot$altitudeChunkBegin ), "m" ,
                          " to ",
                          max( mtrPlot$altitudeChunkEnd ), "m",
                          "\n",
                          paste( classSelection, collapse = ", " ) )
      
      longPlot <- ggplot( mtrPlot, aes( x = as.factor( timeChunkDate ), y = mtr, label = paste0( "N=", nEchoes ), fill = dayOrNight ) ) + 
        geom_col( aes( as.factor( timeChunkDate ), mtr, fill = dayOrNight ), position = "dodge2" )
      if( plotSpread == TRUE )
      {
        longPlot <- longPlot + geom_errorbar( aes( ymin = mtrFirstQuartile, ymax = mtrThirdQuartile ), width = 0.2, position = position_dodge( 0.9 ), color = "grey40" )
      }
      longPlot <- longPlot + geom_col( aes( as.factor( timeChunkDate ), obs, fill = obsType ), position = "dodge2", fill = "grey50" ) + 
        ggtitle( label = "Daily MTR", subtitle = subtitle ) + xlab( "Date" ) + ylab( "MTR [ind./h/km]" ) +
        geom_text( position = position_dodge( width = 0.9 ), aes( y = yScale[ 1 ] * 1.75 , hjust = "bottom", vjust = "center" ), color = "grey60", size = 2.5, angle = 90 ) +
        scale_fill_manual( " ", values = c( "day" = "goldenrod1", "night" = "navy" ) ) +
        scale_x_discrete( labels = function( x ) format( as.Date( x ), "%d-%b-%Y" ) ) +
        coord_cartesian( ylim = yScale ) + 
        theme( plot.title = element_text( size = 12, face = "bold", hjust = 0.5 ),
               plot.subtitle = element_text( size = 10, color = "grey40", hjust = 0.5 ),
               axis.text.x = element_text( angle = 90 ) )
      
      # save plot
      savePlotToFile( plot = longPlot,
                      filePath = filePath, 
                      plotType = "mtrPerDay", 
                      plotWidth_mm = difftime( timeRange[[ i ]][ 2 ], timeRange[[ i ]][ 1 ], "days" ) * 10 + 50, 
                      plotHeight_mm = 150, 
                      timeRange = c( timeRange[[ i ]][ 1 ], timeRange[[ i ]][ 2 ] ), 
                      classSelection = classSelection, 
                      altitudeRange = c( min( mtrPlot$altitudeChunkBegin ), max( mtrPlot$altitudeChunkEnd ) ) )
    }
  }
}

#### plotExploration ------------------------------------------------------
#' @title plotExploration
#'
#' @author Fabian Hertner (SBRS)
#' @description TBC
#' @param echoData dataframe with the echo data from the data list created by the function ‘extractDBData’ or a subset of it created by the function ‘filterEchoData’
#' @param timeRange optional list of POSIXct vectors length 2, start and end time of the timeranges that should be plotted. 
#' The date/time format is “yyyy-MM-dd hh:mm”. Target timezone has to be added to the times (Figure 14 as example). If not set, all echo data is plotted in one plot.  
#' Note: Too long time-ranges may produce an error if the created image is too large and the function can’t allocate the file. 
#' @param manualBlindTimes optional dataframe with the manual blind times created by the function ‘loadManualBlindTimes’. If not set, manual blind times are not shown in the plot. 
#' @param visibilityData optional dataframe with the visibility data created by the function ‘extractDBData’. If not set, visibility data are not shown in the plot. 
#' @param protocolData optional dataframe with the protocol data used to filter the echoes, created by the function ‘extractDBData’ or a subset of it created by the 
#' function ‘filterProtocolData’. If not set, periods without a protocol are not shown in the plot. 
#' @param sunriseSunset optional dataframe with sunrise/sunset and civil twilight times created by the function ‘twilight’. If not set, day/night times are not shown in the plot. 
#' @param maxAltitude optional numeric, fixes the maximum value of the y-Scale of the plot to the given value. If negative or not set, the y-Scale is auto-scaled.
#' @param filePath character string, path of the directory where the plot should be saved. The function ‘savePlotToFile’ is used to save the plots as pngs with an autogenerated filename.
#'
#' @return pngs stored in the directory specified in filePath
#' @export
#'
# #' @examples
# #' # plot Exploration
# #' plotExploration( echoData = echoDataSubset_all_25_5000, timeRange = timeRangePlot, manualBlindTimes = manualBlindTimes, visibilityData = data$visibilityData, protocolData = protocolDataSubset, sunriseSunset = sunriseSunset, maxAltitude = -1, filePath = plotDir )
plotExploration = function( echoData = NULL, timeRange = NULL, manualBlindTimes = NULL, visibilityData = NULL, protocolData = NULL, sunriseSunset = NULL, maxAltitude = NULL, filePath = NULL )
{
  if( !is.null( echoData ) )
  {
    
    # colors for classes
    classColors <- c( "nonbio" = "grey40",
                      "precipitation" = "grey60",
                      "insect" = "orange",
                      "unid_bird" = "darkblue",
                      "passerine_type" = "turquoise3",
                      "wader_type" = "chartreuse3",
                      "swift_type" = "deeppink",
                      "large_bird" = "purple",
                      "bird_flock" = "forestgreen" )
    
    # shapes for classes
    classShapes <- c( "nonbio" = 0,
                      "insect" = 4,
                      "unid_bird" = 1,
                      "passerine_type" = 1,
                      "wader_type" = 1,
                      "swift_type" = 1,
                      "large_bird" = 1,
                      "bird_flock" = 1,
                      "precipitation" = 5 )
    
    # size for shapes
    shapeSizes <- c( "nonbio" = 0.4,
                     "insect" = 2,
                     "unid_bird" = 0.4,
                     "passerine_type" = 0.4,
                     "wader_type" = 0.4,
                     "swift_type" = 0.4,
                     "large_bird" = 0.4,
                     "bird_flock" = 0.4,
                     "precipitation" = 0.4 )
    
    # backgroundDataColor
    backgroundColors <- c( "day" = "goldenrod1",
                           "night" = "navy",
                           "manual blindtime" = "dodgerblue",
                           "visibility blindtime" = "firebrick1",
                           "no protocol" = "turquoise4" )
    
    # day/night colors
    dayNightColors <- c( )
    
    # class levels
    classLevels <- c( "passerine_type", "wader_type", "swift_type", "large_bird", "unid_bird", "bird_flock", "insect", "nonbio", "precipitation" )
    echoData$class <- factor( echoData$class, levels = classLevels )
    
    # background levels
    backgroundLevels <- c( "day", "night", "manual blindtime", "visibility blindtime", "no protocol" )
    
    if( !is.null( sunriseSunset ) )
    {
      # change sunrise/sunset data from 0/1 to day/night
      sunriseSunset$is_night[ sunriseSunset$is_night != 1 ] <- "day"
      sunriseSunset$is_night[ sunriseSunset$is_night == 1 ] <- "night"
    }
    
    # timeRanges to plot
    if( is.null( timeRange ) )
    {
      nPlots <- 1
    } else
    {
      nPlots = length( timeRange )
    }
    
    for( i in 1 : nPlots )
    {
      if( is.null( timeRange ) )
      {
        echoDataPlot <- echoData
      } else
      {
        echoDataPlot <- echoData[ echoData$time_stamp_targetTZ >= timeRange[[ i ]][ 1 ] & echoData$time_stamp_targetTZ <= timeRange[[ i ]][ 2 ], ]  
      }
      
      if( nrow( echoDataPlot ) >= 0 )
      {
        # set y scale
        if( maxAltitude > 0 )
        {
          yScale <- c( -0.03 * maxAltitude, maxAltitude )
        } else
        {
          yScale <- c( -0.03 * max( echoDataPlot$feature1.altitude_AGL ), 1.1 * max( echoDataPlot$feature1.altitude_AGL ) )
        }
        
        # Plot
        subtitle <- paste0( format( timeRange[[ i ]][ 1 ], "%d-%b-%Y" ), 
                            " to ", 
                            format( timeRange[[ i ]][ 2 ], "%d-%b-%Y" ) )
        
        explorationPlot <- ggplot(  )
        
        # create background data
        background <- data.frame( xStart = as.POSIXct( NA ), xStop = as.POSIXct( NA ), yStart = as.numeric( NA ), yStop = as.numeric( NA ), type = factor( NA, levels = backgroundLevels ) )
        
        if( !is.null( manualBlindTimes ) )
        {
          manualBlindTimes$type <- "manual blindtime"
          background <- rbind( background, data.frame( xStart = manualBlindTimes$start_targetTZ, xStop = manualBlindTimes$stop_targetTZ, yStart = -0.06 * yScale[ 2 ], yStop = -0.04 * yScale[ 2 ], type = manualBlindTimes$type ) )
        }
        
        if( !is.null( sunriseSunset ) )
        {
          background <- rbind( background, data.frame( xStart = sunriseSunset$civilStart, xStop = sunriseSunset$civilStop, yStart = 0.93 * yScale[ 2 ], yStop = yScale[ 2 ], type = sunriseSunset$is_night ) )
        }
        
        if( !is.null( visibilityData ) )
        {
          background <- rbind( background, data.frame( xStart = visibilityData$blind_from_targetTZ, xStop = visibilityData$blind_to_targetTZ, yStart = -0.02 * yScale[ 2 ], yStop = -0.00 * yScale[ 2 ], type = "visibility blindtime" ) )  
        }
        
        if( !is.null( protocolData ) )
        {
          background <- rbind( background, data.frame( xStart = protocolData$stopTime_targetTZ[ 1 : length( protocolData[ , 1 ] ) - 1 ], xStop = protocolData$startTime_targetTZ[ 2 : length( protocolData[ , 1 ] ) ], yStart = -0.04 * yScale[ 2 ], yStop = -0.02 * yScale[ 2 ], type = "no protocol" ) )  
        }
        
        # limit background to echoData
        background <- background[ !is.na( background$xStart ), ]
        background <- background[ background$xStop >= min( echoDataPlot$time_stamp_targetTZ ) & background$xStart <= max( echoDataPlot$time_stamp_targetTZ ), ]
        
        # add background to plot
        if( length( background ) > 1 )
        {
          explorationPlot <- explorationPlot + geom_rect( background, mapping = aes( ymin = yStart , ymax = yStop, xmin = xStart, xmax = xStop, fill = type ), alpha = 0.5 )  
        }
        
        # plot echoes
        explorationPlot <- explorationPlot + geom_point( echoDataPlot, mapping = aes( x = time_stamp_targetTZ, y = feature1.altitude_AGL, colour = class, shape = class ), na.rm = TRUE )
        
        # overprint insect classes
        insects <- echoDataPlot[ echoDataPlot$class %in% c( "insect" ) , names( echoDataPlot ) %in% c( "time_stamp_targetTZ", "feature1.altitude_AGL", "class" ) ]
        if( length( insects[ , 1 ] ) )
        {
          insects$class <- factor( insects$class, levels = classLevels )
          explorationPlot <- explorationPlot + geom_point( insects, mapping = aes( x = time_stamp_targetTZ, y = feature1.altitude_AGL, colour = class, shape = class ), na.rm = TRUE )
        }
        
        # overprint bird classes
        birds <- echoDataPlot[ !( echoDataPlot$class %in% c( "insect", "nonbio", "precipitation" ) ) , names( echoDataPlot ) %in% c( "time_stamp_targetTZ", "feature1.altitude_AGL", "class" ) ]
        if( length( birds[ , 1 ] ) )
        {
          birds$class <- factor( birds$class, levels = classLevels )
          explorationPlot <- explorationPlot + geom_point( birds, mapping = aes( x = time_stamp_targetTZ, y = feature1.altitude_AGL, colour = class, shape = class ), na.rm = TRUE )
        }
        
        explorationPlot <- explorationPlot + scale_color_manual( values = classColors ) +
          scale_shape_manual( values = classShapes ) + 
          scale_fill_manual( values = backgroundColors ) +
          coord_cartesian( ylim = yScale )
        
        explorationPlot <- explorationPlot + scale_x_datetime( date_breaks = "1 days", labels = function( x ) format( x, "%d-%b-%Y" ) ) + 
          labs( fill = "", shape = "", colour = "" ) +
          ggtitle( label = "Exploration", subtitle = subtitle ) + xlab( "Date" ) + ylab( "Altitude a.g.l [m]" ) +
          theme( plot.title = element_text( size = 12, face = "bold", hjust = 0.5 ),
                 plot.subtitle = element_text( size = 10, color = "grey40", hjust = 0.5 ),
                 axis.text.x = element_text( angle = 90 ) )
        
        # save plot
        savePlotToFile( plot = explorationPlot, 
                        filePath = filePath, 
                        plotType = "exploration", 
                        plotWidth_mm = difftime( timeRange[[ i ]][ 2 ], timeRange[[ i ]][ 1 ], "days" ) * 100 + 50, 
                        plotHeight_mm = 150, 
                        timeRange = c( timeRange[[ i ]][ 1 ], timeRange[[ i ]][ 2 ] ) )  
      }
    }
  }
}

